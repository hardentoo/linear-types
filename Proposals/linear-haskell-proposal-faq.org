#+TITLE: Linear types proposal: FAQ

* Does this proposal improve performance

No.

This proposal only adds finer types for functions. You can use these
new types to build new abstraction, whether for efficiency reasons or
otherwise.

* Does this proposal change the RTS?

No.

This proposal only affects type-checking. Both in the surface language
and in Core.

* Why does this proposal need to change Core?

There are two reasons:
- In GHC, the type ~Type~ is shared between the surface language and
  Core. So modifying the types implies that Core is modified as well.
- More importantly, because Core is a good check that our
  implementation works as intended. That is, a linearly typed Core
  will ensure that linearly-typed programs are indeed desugared to
  linearly-typed programs in Core. And that optimisations do not
  destroy linearity.

* Isn't a linear function that diverges unsound?

Our proposed type system gives linear type to list concatenation:
#+BEGIN_SRC haskell
  (++) :: [a] ->. [a] ->. [a]
#+END_SRC

So we can write
#+BEGIN_SRC haskell
  strange :: Int ->. [Int]
  strange x = (repeat 1) ++ [x]
#+END_SRC
This sounds like it's breaking the promise made by ~strange~ that it
will consume its argument exactly once. Since ~x~ will /never/ be
consumed!

But there is no cause for panic: ~strange~ only promises to consume
~x~ if its result is consumed. Which will never happen since the
result of ~strange~ is infinite. The properties of linear types which
we need are not compromised by non-termination.

* In the motivations of the proposal, there is a linear IO monad. Isn't linear IO unsound in presence of exception?

No, it isn't. But we are not allowed to use a linear type for [[https://github.com/tweag/linear-base/blob/007b884ebb0e3182ea73e450683f9660b7a92f40/src/System/IO/Linear.hs#L144-L146][~catch~]]:
#+BEGIN_SRC haskell
  catch
    :: Exception e
    => IO (Unrestricted a) -> (e -> IO (Unrestricted a)) -> IO (Unrestricted a)
#+END_SRC
It means that neither the body nor the handler of ~catch~ can capture
linear variables. Otherwise, you could lose track of them.

If, say, the body of ~catch~ was linear, we could write:
#+BEGIN_SRC haskell
  oops :: a ->. IO (Unrestricted ())
  oops x =
    catch
      (throwIO "This is bad" >> oops a)
      (\_ -> return $ Unrestricted ())
#+END_SRC

* Don't linear guarantees degrade to affine in presence of exceptions?

When an exception is raised during the consumption of ~f u~, ~u~ may
not have been fully consumed. Functions whose argument is consumed /at
most/ once when their result is consumed exactly once are called
affine.

Linear functions do have the property that: /if their result is
consumed at most once, then their argument is consumed at most
once/. This is a more relevant phenomenon in case exceptions are
raised: exceptions interrupt the consumption of the result, which is
only partial.

In fact, linear functions have the property that if their result is
consumed with multiplicity X, then their argument is also consumed
with multiplicity X. Whatever choice of multiplicity we add to the
language. Which can be internalised in the language as follows
#+BEGIN_SRC haskell
  data Mult (p :: Multiplicity) (a :: *) where
    Mult :: a :p-> Multp p a

  multMap :: (a->.b) -> Mult p a -> Mult p b
  multMap f (Mult x) = Mult (f x)
#+END_SRC

* Wouldn't it be just as good to have affine types, since they are simpler?

Having affine types would makes some things easier. For instance
~catch~ is allowed to capture affine variables:
#+BEGIN_SRC haskell
  -- Writing A for the multiplicity of affine functions
  catch
    :: Exception e
    => IO (Unrestricted a) :'A-> (e -> IO (Unrestricted a)) :'A-> IO (Unrestricted a)
#+END_SRC

However, the Rust programming language, with his (essentially) affine
language has shunned exceptions for a reason: they are still quite a
complication.

Nevertheless, affine types are sufficient for abstractions based on
ownership, as long as you don't care about prompt deallocation
(mutable arrays on the GC heap are a good exemple).

To recover prompt deallocation, Rust relies on bespoke mechanism
(lifetime analysis) and code generation to an essentially linear
language. This is something which is not reasonable to hope for
Haskell at the moment.

Use-cases which do not rely on uniqueness, such as Samuel Gelinaux's
[[https://www.spiria.com/en/blog/desktop-software/making-non-manifold-models-unrepresentable][3D-printable model example]] (which he also implemented with our
prototype [[https://github.com/gelisam/linear-examples][here]]) may not accomodate affinity so well.

Offering affine types in addition to linear types would probably be
worthwhile but we prefer to focus on the simples core. And add more
multiplicities in a later proposal.

* Do linear types guarantee resource safety?

No. Linear types only gives a type to functions which consume their
argument exactly once when their result is consumed exactly once.

Having linear types is powerful, and makes it possible to write
[[resource-safe abstractions]]. But this is not an intrinseque quality of
the type system.

* Will base be modified to use linear types?

Not at first. When it happens it will be as a separate proposal to the
library committee.

Before we are ready to make a proposal, we want to develop a [[https://github.com/tweag/linear-base/][linearly
typed library]] driven by other programs, so that our choice of basic
functions is well-validated before it is submitted for integration.

* Will adding linear types fragment the libraries ecosystem?

The centerpiece of our design is to avoid most code
duplication. Crucially the same types can be used in linear and
non-linear contexts. In particular our [[https://github.com/tweag/linear-base/][~linear-base~]] library uses the
same types as ~base~. So libraries developped with ~linear-base~ will
be compatible with libraries developped with ~base~.

Of course, some functionality may be duplicated to leverage linear
types. But we except less duplication and fragmentation than
abstractions based on rank-2 types cause, for instance.

* Is this type for monads right?

The linear types proposal features monads with the following interface
#+BEGIN_SRC haskell
  return :: a ->. m a
  (>>=) :: m a ->. (a ->. m b) ->. m b
#+END_SRC
But unfolding the definitions of the Kleisli extension and unit of a
monad you would get instead
#+BEGIN_SRC haskell
  return :: a -> m a
  extend :: (a ->. m b) -> (m a ->. m b)
#+END_SRC

Which is right? The latter type is actually not very useful, but it
would feel uncomfortable if the former type was not backed by
well-known mathematics.

Fortunately it is: it is the type of an enriched monad over the
self-enrichment of the base category. Briefly:

- An [[https://en.wikipedia.org/wiki/Enriched_category][enriched category]] is a category whose hom-sets are taken to be
  objects in another category (which must be monoidal)
- Any closed symmetric monoidal category is enriched over itself
- The category of Haskell types and linear functions is closed
  symmetric monoidal (with the usual [[http://math.andrej.com/2016/08/06/hask-is-not-a-category/][provisos]]), let's call it LHask.
- Monads of LHask for which the unit and join are maps in LHask are
  called enriched monads.

This is related to the often overlooked fact that monads must be
[[https://en.wikipedia.org/wiki/Strong_monad][strong]], both in Moggi's theory of effects, and as a programming
language construct. It is easy to overlooked because (self-)enriched
monads are necessarily strong. And all monads in Hask are, naturally,
self-enriched. See [[https://ncatlab.org/nlab/show/tensorial+strength][this discussion]] for more details.
