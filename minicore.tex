\documentclass{article}

\usepackage[backend=biber,citestyle=authoryear,style=alphabetic]{biblatex}
% \usepackage{natbib}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{cmll}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
  }
\usepackage{mathpartir}
\usepackage{unicode-math}
\usepackage[plain]{fancyref}
\def\frefsecname{Sec.}
\def\freffigname{Fig.}
\def\frefdefname{Def.}
\def\Frefdefname{Def.}
\def\freflemname{Lemma}
\def\Freflemname{Lemma}
\def\frefthmname{Theorem}
\def\Frefthmname{Theorem}
\def\frefappendixname{Appendix}
\def\Frefappendixname{Appendix}
\def\fancyrefdeflabelprefix{def}
\frefformat{plain}{\fancyrefdeflabelprefix}{{\frefdefname}\fancyrefdefaultspacing#1}
\Frefformat{plain}{\fancyrefdeflabelprefix}{{\Frefdefname}\fancyrefdefaultspacing#1}
\def\fancyreflemlabelprefix{lem}
\frefformat{plain}{\fancyreflemlabelprefix}{{\freflemname}\fancyrefdefaultspacing#1}
\Frefformat{plain}{\fancyreflemlabelprefix}{{\Freflemname}\fancyrefdefaultspacing#1}
\def\fancyrefthmlabelprefix{thm}
\frefformat{plain}{\fancyrefthmlabelprefix}{{\frefthmname}\fancyrefdefaultspacing#1}
\Frefformat{plain}{\fancyrefthmlabelprefix}{{\Frefthmname}\fancyrefdefaultspacing#1}
\def\fancyrefappendixlabelprefix{appendix}
\frefformat{plain}{\fancyrefappendixlabelprefix}{{\frefappendixname}\fancyrefdefaultspacing#1}
\Frefformat{plain}{\fancyrefappendixlabelprefix}{{\Frefappendixname}\fancyrefdefaultspacing#1}

\usepackage{xspace}
\newcommand{\ghc}{\textsc{ghc}\xspace}
\newcommand{\eg}{\textit{e.g.}\xspace}
\newcommand{\ie}{\textit{i.e.}\xspace}

\newcommand{\case}[3][]{\mathsf{case}_{#1} #2 \mathsf{of} \{#3\}^m_{k=1}}
\newcommand{\casebind}[4][]{\mathsf{case}_{#1} #2 \mathsf{of} #3 \{#4\}^m_{k=1}}
\newcommand{\data}{\mathsf{data} }
\newcommand{\where}{ \mathsf{where} }
\newcommand{\inl}{\mathsf{inl} }
\newcommand{\inr}{\mathsf{inr} }
\newcommand{\flet}[1][]{\mathsf{let}_{#1} }
\newcommand{\fin}{ \mathsf{in} }
\newcommand{\varid}[1]{\ensuremath{\Varid{#1}}}
\newcommand{\susp}[1]{⟦#1⟧}

%% Metatheory
\newcommand{\termsOf}[1]{\mathnormal{terms}(#1)}
\newcommand{\multiplicatedTypes}[1]{\bigotimes(#1)}
\newcommand{\ta}[2]{γ(#1)(#2)}
%% /Metatheory

\newcommand{\figuresection}[1]{\par \addvspace{1em} \textbf{\sf #1}}


\usepackage{xargs}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
% ^^ Need for pgfsyspdfmark apparently?
\ifx\noeditingmarks\undefined
    % \setlength{\marginparwidth}{1.2cm} % Here's a size that matches the new PACMPL format -RRN
    \newcommand{\Red}[1]{{\color{red}{#1}}}
    \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
    \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
    \newenvironment{alt}{\color{red}}{}

    \newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
    \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
    \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
    \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
    \newcommandx{\critical}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=red,#1]{#2}}
    \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
    \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question

    \newcommandx{\rn}[1]{\todo[]{RRN: #1}} % Peanut gallery comments by Ryan.
    \newcommandx{\simon}[1]{\todo[]{SPJ: #1}}
    \newcommandx{\jp}[1]{\todo[linecolor=blue,bordercolor=blue,backgroundcolor=cyan!10]{JP: #1}{}}
    \newcommand{\manuel}[1]{\todo[linecolor=purple,bordercolor=purple,backgroundcolor=blue!10]{Manuel: #1}{}}

\else
%    \newcommand{\Red}[1]{#1}
    \newcommand{\Red}[1]{{\color{red}{#1}}}
    \newcommand{\newaudit}[1]{#1}
    \newcommand{\note}[1]{}
    \newenvironment{alt}{}{}
%    \renewcommand\todo[2]{}
    \newcommand{\unsure}[2]{}
    \newcommand{\info}[2]{}
    \newcommand{\change}[2]{}
    \newcommand{\inconsistent}[2]{}
    \newcommand{\critical}[2]{}
    \newcommand{\improvement}[1]{}
    \newcommand{\resolved}[2]{}
    \newcommand{\rn}[1]{}
    \newcommand{\simon}[1]{}
    \newcommand{\jp}[1]{}
    \newcommand{\manuel}[1]{}
\fi

% Link in bibliography interpreted as hyperlinks.
\newcommand{\HREF}[2]{\href{#1}{#2}}

% \newtheorem{definition}{Definition}
% \newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}

\newcommand\HaskeLL{Linear Haskell\xspace{}}
\newcommand\calc{{\ensuremath{λ^q_\to}}}
%%%%%%%%%%%%%%%%% /Author's configuration %%%%%%%%%%%%%%%%%

\begin{document}

\title{Linear Mini-Core}

\author{J.-P. Bernardy, M. Boespflug, R. Newton, S. Peyton Jones, and
  A. Spiwack}
\date{}

\maketitle

\section{Differences between Core and the \calc{}}

The goal of this note is to document the differences between \calc{},
as described in the \href{https://arxiv.org/abs/1710.09756}{Linear
  Haskell} paper, and Core, the intermediate language of \textsc{ghc}.

We shall omit, for the time being, the minor differences, such as the
absence of polymorphism on types (\calc{} focuses on polymorphism of
multiplicities), as we don't anticipate that they cause additional
issues.

\improvement{Maybe we should give a typing rule for (mutally)
  recursive lets. Despite it probably being messy.}

\subsection{The case-binder}

In \calc{}, the case construction has the form

$$
\case[π] t {c_k  x₁ … x_{n_k} → u_k}
$$

In Core, it has an additional binder

$$
\casebind t z {c_k  x₁ … x_{n_k} → u_k}
$$
\improvement{Case expressions don't need to have all the
  constructors. They can also have a wildcard pattern, which we need
  to explain.}

The additional variable $z$, called the case binder, is used in a
variety of optimisation passes, and also represents variable patterns.

A proper handling of the case binder is key, in particular, to the
compilation of deep pattern matching.

A difficulty is that for linear case, the case binder cannot be used
at the same time as the variables from the pattern: it would violate
linearity. Additionally the case binder is typically used with
different multiplicity in different branches. And all these rule must
also handle the case where $π$ is chosen to be a variable $p$.

\section{Linear Mini-Core}

\subsection{Syntax}
\newcommand{\pip}{\kern 1.18em || }
\label{sec:syntax}

The syntax is modified to include case binders. See
\fref{fig:syntax}.

\begin{figure}
  \begin{minipage}{0.4 \textwidth} \centering
  \figuresection{Multiplicities}
  \begin{align*}
    π,μ &::= 1 ~||~ ω ~||~ p ~||~ π+μ ~||~ π·μ
  \end{align*}
  \end{minipage}
\\[3mm]
  \begin{minipage}{0.4 \textwidth} \centering
  \figuresection{Types}
  \begin{align*}
  A,B ::= A →_π B ~||~  ∀p. A ~||~ D~p_1~…~p_n
  \end{align*}
  \end{minipage}
\\[3mm]
  \begin{minipage}{0.3 \textwidth} \centering
  \figuresection{Contexts}
  \begin{align*}
    Γ,Δ & ::=  (x :_{μ} A), Γ ~||~ –
  \end{align*}
  \end{minipage}
\\[3mm]
  \begin{minipage}{0.6\linewidth} \centering
    \figuresection{Datatype declaration}
    \begin{align*}
      \data D~p_1~…~p_n~\mathsf{where} \left(c_k : A₁ →_{π₁} …    A_{n_k} →_{π_{n_k}} D\right)^m_{k=1}
    \end{align*}
  \end{minipage}

  \figuresection{Terms}
  \begin{align*}
    e,s,t,u & ::= x & \text{variable} \\
            & \pip λ_π (x{:}A). t & \text{abstraction} \\
            & \pip t s & \text{application} \\
            & \pip λp. t & \text{multiplicity abstraction} \\
            & \pip t π & \text{multiplicity application} \\
            & \pip c t₁ … t_n & \text{data construction} \\
            & \pip \casebind[π] t z {c_k  x₁ … x_{n_k} → u_k}  & \text{case} \\
            & \pip \flet[π] x_1 : A₁ = t₁ … x_n : A_n = t_n \fin u & \text{let}
  \end{align*}

  \caption{Syntax of \calc{}}
  \label{fig:syntax}
  \label{fig:contexts}
\end{figure}

\subsection{Static Semantics}
\label{sec:typing-contexts}

See \fref{fig:typing}.\improvement{Explain in English the basic idea
  of the case rule with case binder.}

%%% typing rule macros %%%
\newcommand{\apprule}{\inferrule{Γ ⊢ t :  A →_π B  \\   Δ ⊢ u : A}{Γ+πΔ ⊢ t u  :  B}\text{app}}
\newcommand{\varrule}{\inferrule{ }{ωΓ + x :_1 A ⊢ x : A}\text{var}}
\newcommand{\caserule}{\inferrule{Γ   ⊢  t  : D~π_1~…~π_n \\
      Δ, z:_ν D~π_1~…~π_n, x₁:_{πρ_1} A_i, …, x_{n_k}:_{πρ_{n_k}} A_{n_k} ⊢ u_k : C \\
      ρ_1+νμ_1[π_1…π_n]=πμ_1[π_1…π_n]\quad…\quad ρ_{n_k}+νμ_{n_k}[π_1…π_n]=πμ_{n_k}[π_1…π_n]\\
      \text{for each $c_k : A_1 →_{μ_1} … →_{μ_{n_k-1}} A_{n_k} →_{μ_{n_k}} D~p_1~…~p_n$}}
    {πΓ+Δ ⊢ \casebind[π] t z {c_k  x₁ … x_{n_k} → u_k} : C}\text{case}}
%%% /macros %%%

\begin{figure}
  \begin{mathpar}
    \varrule

    \inferrule{Γ, x :_{π} A  ⊢   t : B}
    {Γ ⊢ λ_π (x{:}A). t  :  A  →_π  B}\text{abs}

    \apprule

    \inferrule{Δ_i ⊢ t_i : A_i \\ \text {$c_k : A_1 →_{μ_1} … →_{μ_{n-1}}
        A_n →_{μ_n} D~p_1~…~p_n$ constructor}}
    {ωΓ+\sum_i μ_i[π₁…π_n]Δ_i ⊢ c_k  t₁ … t_n : D~π₁~…~π_n}\text{con}

    \caserule

    \inferrule{Γ_i   ⊢  t_i  : A_i  \\ Δ, x₁:_{π} A₁ …  x_n:_{π} A_n ⊢ u : C }
    { Δ+π\sum_i Γ_i ⊢ \flet[π] x_1 : A_1 = t₁  …  x_n : A_n = t_n  \fin u : C}\text{let}

    \inferrule{Γ ⊢  t : A \\ \text {$p$ fresh for $Γ$}}
    {Γ ⊢ λp. t : ∀p. A}\text{m.abs}

    \inferrule{Γ ⊢ t :  ∀p. A}
    {Γ ⊢ t π  :  A[π/p]}\text{m.app}
  \end{mathpar}

  \caption{Typing rules}
  \label{fig:typing}
\end{figure}

\section{Examples}

Take, as an example, the following Linear Haskell function:
\begin{verbatim}
data Colour = { Red; Green; Blue }

f :: Colour ->. Colour ->. Colour
f Red q = q
f p Green = p
f Blue q = q
\end{verbatim}
This is compiled in Core as
\begin{verbatim}
f = \ (p ::('One) Colour) (q ::('One) Colour) ->
  case(1) p of p2
  { Red -> q;
    WILDCARD ->
     case(1) q of q2
     { Green -> p2;
     WILDCARD ->
       case(1) p2 of p3 { Blue -> q2 }
  }}
\end{verbatim}
This is well typed because (focusing on the case of \verb+p2+)
\begin{itemize}
\item In the \verb+Red+ branch, no variables are introduced by the
  constructor\improvement{There maybe be a missing bit here, in the rules,
    as typeset, this also means that I can use p2
    unrestrictedly. This does not actually seem incorrect, surprising
    thought it is, but it may be worth checking. }
\item In the \verb+WILDCARD+ branch, we see \verb+WILDCARD+ as a
  variable which can't be referenced, from the rules we get that the
  multiplicity of \verb+WILDCARD+ (necessarily $0$) plus the
  multiplicity of \verb+p2+ must be $1$. Which is the case as $p2$ is
  used linearly in each branch.
\end{itemize}

This example illustrates that, even in a multi-argument equation
setting, the compiled code is linear when all the equations,
individually, are linear.

\section{Typechecking linear Mini-Core}

\newcommand{\type}[1]{\mathsf{type}(#1)}
\newcommand{\mult}[1]{\mathsf{mult}(#1)}
\newcommand{\typeof}[1]{\mathsf{typeOf}(#1)}

It may appear that typechecking the case rule requires guessing
multiplicities $ν$ and $ρ_i$ so that they verify the appropriate
constraint given from the context. But it is in fact not the case as
the multiplicity will be an output of the type-checker.

In this section we shall sketch how type-checking can be performed on
Linear Core.

\subsection{Representation}

Core, in \textsc{ghc}, attaches its type to every variable (let's call
it $\type{x}$). Similarly, in Linear Core, variables come with a
multiplicity ($\mult{x}$). Contrary to $\type{x}$, which is used both
at binding and call sites, $\mult{x}$ will only be used at binding
site.

The multiplicity index on a case expression is represented by
$\mult{z}$, where $z$ is the case-binder

\subsection{Algorithm sketch}

The typechecking algorithm, $\typeof{t}$, takes as an input a Linear
Core term $t$, and returns a pair of
\begin{itemize}
\item The type of the term
\item A mapping of every variable to its multiplicity
\end{itemize}

The algorithm is as follows (main cases only):\improvement{Explain
  sum, scaling, and join for mapping. Explain multiplicity
  ordering. Explain how zero-usage is handled. Explain how empty cases
  are handled.}
\begin{itemize}
\item $\typeof{x} = (\type{x}, x ↦ \mult{x})$
\item $\typeof{u v} = (B, m_u + πm_v)$ where
  $(A →_π B, m_u)=\typeof{u}$ and $(A, m_v)=\typeof{v}$
\item $\typeof{λ_π x : A. u}=(A →_π B, m)$ where $(B, (x ↦ ρ, m)) =
  \typeof{u}$ and $ρ ⩽ π$
\item $\typeof{\casebind[π] u z {c_k  x₁ … x_{n_k} →
      v_k}}=(A,πm_u + ⋁_{k=1}^m m_k)$, where the $c_k : B_1^k
  →_{μ_1^k} … B_{n_k}→_{μ_{n_k}^k} → D$ are constructors of
  the data type $D$, $(m_u, D) = \typeof{u}$, $(A, (z ↦ ν^k, x_1 ↦
  ρ_1^k, …, p_{n_k}^k, m_k)) = \typeof{v_k}$ and $ρ_i^k+ν^kμ_i^k =
  πμ_i^k$ for all $i$ and $k$.
\end{itemize}

\end{document}

% Local Variables:
% ispell-local-dictionary: "british"
% End:
